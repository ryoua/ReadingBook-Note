# 可恢复操作的问题和模型
## 故障模式
* 错误数据输入
* 介质故障
* 灾难性故障
* 系统故障
## 关于事务的讨论
> 事务是数据库操作执行的单位，一旦对数据库进行的操作开始执行，事务就随之开始，而事务的结束使用显式的COMMIT或ROLLBACK命令

## 事务原语操作
* INPUT(X): 将包含数据库元素X的磁盘块拷贝到主缓冲区
* READ(X, t): 将数据库元素X拷贝到事务的局部变量t
* WRITE(X, t): 将局部变量t的值拷贝到主缓冲区的数据库元素X
* OUTPUT(X): 将包含X的缓冲区中的块拷贝回磁盘

# undo日志
> undo日志通过撤销事务在系统崩溃前可能还没完成的影响来修复数据库状态
## 日志记录
* <START T>: 表示事务T已经开始
* <COMMIT T>: 事务T已经完成并对数据库元素不再有修改
* <ABORT T>: 事务T不能成功完成
    
更新记录: 一个三元组<T, X, v>, 含义是:事务T改变了数据库元素X, 而X的原来的值是v, 更新记录反映的改变通常是在主存中而不是磁盘上. 另外undo日志不记录数据库元素的新值. 
## undo日志规则
只要遵循以下两条规则, undo日志就能保住恢复
* 如果事务T改变了元素X, 那么形如<T, X, v>的日志记录必须在X的新值写到磁盘之前写到磁盘中
* 如果事务提交, 则其commit日志记录必须在事务改变的所有数据库元素先写到磁盘之后写到磁盘中

简要概括就是说事务相关内容必须按如下顺序写入磁盘:
1. 指明所改变数据库元素的日志记录
2. 改变的数据库元素自身
3. commit日志记录

例子:
![](https://cdn.jsdelivr.net/gh/chch455/tuchuang/2020/04/30/edc0ad055b0b664e46c441d6b2324988.png)

## 使用undo日志的恢复
首先恢复管理器将事务划分为已提交事务和未提交事务,如果有日志记录<COMMIT T>, 那么根据undo的规则2, 事务T所做的全部改变在此之前已经全部写入磁盘, 所有T不可能使数据库处于不一致的状态. 然后如果我们发现了<START T>, 但是没有发现<COMMIT T>, 那么有可能是崩溃前T对数据库所做的某些修改已经写到磁盘, 而T的另一些修改在主存缓冲区中都还没有进行, 或者在缓冲区进行了但还为拷贝到磁盘上, 这种情况下, T是一个未完成事务, 因此必须被撤销, 根据规则1, 恢复时可以为数据库元素X写入值v

## 检查点
原则上, 一旦事务的COMMIT记录被写到磁盘, 该事务的日志记录在恢复时就不再需要, 我们可以设想在COMMIT之前删除日志, 但是因为很多事务是同时执行的, 所以不能这样做, 最简单的办法是周期性对日志做检查点. 在一个检查点中, 我们可以
1. 停止接受新的事务
2. 等到所有活跃的事务提交或中止, 并且在日志中写入COMMIT或ABORT记录
3. 将日志刷新到磁盘
4. 写入日志记录<CKRT>, 并再次刷新日志
5. 重新开始接受事务
恢复时, 从日志尾部开始向后扫描, 看到<CKRT>记录时, 我们知道我们已经看到了所有未完成的事务. 
例子:
![](https://cdn.jsdelivr.net/gh/chch455/tuchuang/2020/05/01/2d51b30ed915d5f78dbcd8f8e0ff38a6.png)

## 非静止检查点
1. 写入日志记录<START CKRT(T1, ..., Tk)>并刷新日志, 其中T1, ..., TK是所有活跃事务(即尚未提交和将其修改写到磁盘的事务)的名字或标识符
2. 等待T1, ..., TK中的所有事务提交或中止, 但允许提交事务开始
3. 当T1, ..., TK都已完成时, 写入日志记录<END CKRT>并刷新日志
恢复时:
![](https://cdn.jsdelivr.net/gh/chch455/tuchuang/2020/05/01/635f10d442d80b073b4bfe7186a5982e.png)

例子:
![](https://cdn.jsdelivr.net/gh/chch455/tuchuang/2020/05/01/3e32625e9b2943c0079c013fe55edb02.png)

# redo日志
> undo日志有个问题, 在将事务改变的所有数据写到磁盘前, 不能提交该事务.

redo日志和undo日志的区别:
* undo日志在恢复时消除未完成事务的影响并忽略已提交事务, 而redo日志忽略未完成的事务并重复已提交事务所做的改变
* undo日志要求在commit日志到达磁盘前将修改后的数据库元素写到磁盘, redo日志要求commit记录在任何修改后的值到达磁盘前出现在磁盘上
* 当遵循undo规则1, 2时, 恢复时我们需要改变的数据库元素旧值, 而redo需要的是新值

## redo日志规则
